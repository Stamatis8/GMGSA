29/08/22
# Description

	WigleyModeler Wigley {{0.8,1.2},{0.08,0.12},{0.05,0.075},0.2,0,1};

	WigleyAnalyticMoments WigleyAnalytic {Wigley};

DRS was used for sampling generation

## DRS with uniform sampling
	#ifndef DRS_HPP
	#define DRS_HPP

	#include <vector>
	#include <cmath>

	#include "combinations.hpp"

	std::vector<std::vector<double>> DRS(
	std::vector<std::vector<double>> X,
	std::vector<std::vector<double>> S_prev,
	int N,
	int iterations);

	std::vector<std::vector<double>> DRS(
	std::vector<std::vector<double>> X,
	std::vector<std::vector<double>> S_prev,
	int N,
	int iterations)
	{
	/*
		Description: X specifies the design space. Random samples are generated in said design space. First X is
			discretized into approximately a number sub-hypercubes. Then, at the 0th iteration, one design is randomly generated 
			in each sub-hypercube. After this, for each iteration the samples move towards the centroid of the hypercube they
			belong by a specified amount

		Input:

			- std::vector<std::vector<double>> X
				Design space limits. The ith parameter in X is bounded by [X.at(i-1).at(0), X.at(i-1).at(1)]
				X.size() >= 1
				X.at(i).size() == 2 for every i
			- std::vector<std::vector<double>> S_prev
				Previous sampling
				New samples avoid previous samples at each iteration
				Previous samples must have been generated by the same algorithm and have the same size
			- int N
				Number of samples to construct
				N >= 1
			- int iterations
				number of iterations
				iterations >= 0
				if iterations == 0, one design is generated in each sub-hypercube
					and the result is returned

		Output:

			- std::vector<std::vector<double>> S
				 ceil(N^{1/n})^n samples from X
	*/

	auto pow = [](int base, int exponent) {// pow lambda
		int result = 1;
		for (int i = 0; i < exponent; i++) {
			result *= base;
		}
		return result;
	};

	double n = X.size(); // dimension of design space

	int m = std::ceil(std::pow(N, 1/n)); // number of subintervals in each parameter-range
	
	N = pow(m, n); // actual number of samples which will be generated

	/* Creating Discretization of X */

	std::vector<double> Delta(n, 0);// discretization size of each parameter range (each is divided into m segments)
	for (int i = 0; i < n; i++) {
		Delta.at(i) = (X.at(i).at(1) - X.at(i).at(0)) / m;
	}
	std::vector<std::vector<double>> X_discrete(n, std::vector<double>(m + 1, 0));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < (m + 1); j++) {
			X_discrete.at(i).at(j) = X.at(i).at(0) + (X.at(i).at(1) - X.at(i).at(0)) * j / m;
		}
	}

	/* Randomly generating one sample per sub-hypercube and calculating hypercube centroids */

	std::vector<std::vector<double>> S(N, std::vector<double>(n, 0)); // final-samples
	std::vector<std::vector<int>> comb = combinations(n, m); // combinations.at(i) = ith hypercube
	std::vector<std::vector<double>> centroids(N, std::vector<double>(n, 0)); // centroids of hypercubes
	int c;// current discrete coordinate (ie each hypercube is located at n discrete coordinates)

	for (int i = 0; i < N; i++) {// samples
		for (int d = 0; d < n; d++) {// dimensions
			c = comb.at(i).at(d);
			S.at(i).at(d) = X_discrete.at(d).at(c) + (X_discrete.at(d).at(c+1) - X_discrete.at(d).at(c)) * rand() / RAND_MAX;
			centroids.at(i).at(d) = (X_discrete.at(d).at(c) + X_discrete.at(d).at(c + 1)) / 2;
		
			//DEBUG
			S.at(i).at(d) = X_discrete.at(d).at(c) + (X_discrete.at(d).at(c + 1) - X_discrete.at(d).at(c)) * 0.25;
		}
	} 

	/* For each iteration adjusting moving each sample towards centroid */

	double p = 0.35;// percentage of distance to hypercube centroid to be covered in each iteration
	double p_prev = 0.65;// percentage of distance to prev point to be avoided in each iteration

	for (int i = 0; i < iterations; i++) {
		if (S_prev.size() != 0) {// avoid S_prev
			for (int i = 0; i < N; i++) {// samples
				for (int d = 0; d < n; d++) {// dimensions
					c = comb.at(i).at(d);
					S.at(i).at(d) = S.at(i).at(d) - (S_prev.at(i).at(d) - S.at(i).at(d)) * p_prev;
					if (S.at(i).at(d) > X_discrete.at(d).at(c + 1)) S.at(i).at(d) = X_discrete.at(d).at(c + 1); 
					else if (S.at(i).at(d) < X_discrete.at(d).at(c)) S.at(i).at(d) = X_discrete.at(d).at(c);
				
					S.at(i).at(d) = S.at(i).at(d) + (centroids.at(i).at(d) - S.at(i).at(d)) * p;
				
					//DEBUG
					S.at(i).at(d) = X_discrete.at(d).at(c) + (X_discrete.at(d).at(c + 1) - X_discrete.at(d).at(c)) * 0.75;
				}
			}
		}
		else {
			for (int i = 0; i < N; i++) {// samples
				for (int d = 0; d < n; d++) {// dimensions
					S.at(i).at(d) = S.at(i).at(d) + (centroids.at(i).at(d) - S.at(i).at(d)) * p;
				}
			}
		}
	}// i

	return S;
	}

	#endif// DRS_HPP

look at `10e2_2D_uniform_samples_example.png` for an example of this

## DRS with standard method

### `10e3_10e4_uniform_samples.png`

results were generated with 0 iterations for first DRS run in GMGSA and 1 iterations for second DRS run in GMGSA

### `10e3_10e4_standard_DRS_samples.png`

results were generated with 1 iteration for first DRS run in GMGSA and 5 iterations for second DRS run in GMGSA

### `10e2_2D_uniform_samples.png`

0 iterations for first DPS run, 1 iteration for second DPS run

### `10e2_2D_standard_DRS_samples.png`

1 iteration for first DPS run, 3 for second DPS run

### `10e2_2D_DPS_samples.png`

	//std::vector<std::vector<double>> S = DRS({ {-1,1},{-1,1} }, std::vector<std::vector<double>>(), N, 1);

	std::vector<std::vector<double>> S = DPS({ {-1,1},{-1,1} }, std::vector<std::vector<double>>(), N, 2, 3, 1);

	//std::vector<std::vector<double>> S_new = DRS({ {-1,1},{-1,1} }, S, N, 3);

	std::vector<std::vector<double>> S_new = DPS({ {-1,1},{-1,1} }, S, N, 2, 3, 1);